// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Text;
using LibMMD.Material;
using UnityEngine;

namespace LibMMD.Unity3D
{
	public class MaterialLoader : IDisposable
	{
		private const bool EnableVerboseLogs = false;
		private static readonly bool EnableTextureTraceLogs = EnableVerboseLogs || ReadTextureTraceFlag();
		public const string MainTextureStatusTag = "MASCOT_MAIN_TEX_STATUS";
		public const string MainTextureStatusLoaded = "loaded";
		public const string MainTextureStatusLoadedFallbackWhite = "loaded_fallback_white";
		public const string MainTextureStatusMissingSpec = "missing_spec";
		public const string MainTextureStatusMissingResolve = "missing_resolve";
		public const string TextureStatusNotUsed = "not_used";
		public const string ToonTextureStatusTag = "MASCOT_TOON_TEX_STATUS";
		public const string SphereAddTextureStatusTag = "MASCOT_SPHERE_ADD_TEX_STATUS";
		public const string SphereMulTextureStatusTag = "MASCOT_SPHERE_MUL_TEX_STATUS";
		public const string TransparentReasonTag = "MASCOT_TRANSPARENT_REASON";
		public const string TransparentReasonOpaque = "opaque";
		public const string TransparentReasonDiffuseAlpha = "diffuse_alpha";
		public const string TransparentReasonEdgeAlpha = "edge_alpha";
		public const string TransparentReasonTextureAlpha = "texture_alpha";
		private const float StrongTransparentAlphaThreshold = 0.20f;
		private const float SemiTransparentAlphaThreshold = 0.60f;
		// Equivalent to 32/1000; keeps prior tuning but scales with texture size.
		private const float StrongTransparentPixelRatioThreshold = 0.032f;
		private const float SemiTransparentPixelRatioThreshold = 0.10f;
		private const float RatioThresholdEpsilon = 0.000001f;
		
		private readonly TextureLoader _textureLoader;
		private readonly Dictionary<int, bool> _textureTransparencyCache = new Dictionary<int, bool>();

		private static bool ReadTextureTraceFlag()
		{
			var flag = Environment.GetEnvironmentVariable("MASCOTDESKTOP_PMX_TEXTURE_TRACE");
			return string.Equals(flag, "1", StringComparison.OrdinalIgnoreCase)
			       || string.Equals(flag, "true", StringComparison.OrdinalIgnoreCase);
		}

		public MaterialLoader(TextureLoader textureLoader) {
			_textureLoader = textureLoader;
		}

		public UnityEngine.Material LoadMaterial(MmdMaterial mmdMaterial, MmdUnityConfig config) {
			var mainTexture = _textureLoader.LoadTexture(mmdMaterial.Texture);
			bool isTransparent;
			var transparentReason = ResolveTransparentReason(mmdMaterial, mainTexture, out isTransparent);
			if (EnableTextureTraceLogs)
			{
				var texPath = mmdMaterial.Texture != null ? mmdMaterial.Texture.TexturePath : "(null)";
				Debug.LogFormat("Material '{0}': transparent={1}, reason={2}, texPath={3}", mmdMaterial.Name, isTransparent, transparentReason, texPath);
			}
			var material = new UnityEngine.Material (GetShader (mmdMaterial, config, isTransparent));
			ConfigMaterial(mmdMaterial, config, material, mainTexture, transparentReason);
			return material;
		}
		public void RefreshMaterialConfig(MmdMaterial mmdMaterial,MmdUnityConfig config, UnityEngine.Material material)
		{
			var mainTexture = _textureLoader.LoadTexture(mmdMaterial.Texture);
			bool isTransparent;
			var transparentReason = ResolveTransparentReason(mmdMaterial, mainTexture, out isTransparent);
			if (EnableTextureTraceLogs)
			{
				var texPath = mmdMaterial.Texture != null ? mmdMaterial.Texture.TexturePath : "(null)";
				Debug.LogFormat("Material '{0}' refresh: transparent={1}, reason={2}, texPath={3}", mmdMaterial.Name, isTransparent, transparentReason, texPath);
			}
			var shaderName = BuildShaderName(mmdMaterial, config, isTransparent);
			if (!material.shader.name.Equals(shaderName))
			{
				material.shader = Shader.Find(shaderName);
			}
			ConfigMaterial(mmdMaterial, config, material, mainTexture, transparentReason);
		}
		
		private void ConfigMaterial(MmdMaterial mmdMaterial, MmdUnityConfig config, UnityEngine.Material material, Texture mainTexture, string transparentReason)
		{
			if (EnableTextureTraceLogs)
			{
				var texPath = mmdMaterial.Texture != null ? mmdMaterial.Texture.TexturePath : "(null)";
				Debug.LogFormat("Material '{0}': mainTexture={1}, texPath={2}", 
					mmdMaterial.Name, mainTexture != null ? "loaded" : "NULL", texPath);
				Debug.LogFormat("Material Config: Diffuse={0} Ambient={1} Specular={2} Shininess={3}", 
					mmdMaterial.DiffuseColor, mmdMaterial.AmbientColor, mmdMaterial.SpecularColor, mmdMaterial.Shiness);
			}
			
			material.SetColor("_Color", mmdMaterial.DiffuseColor);
			material.SetFloat("_Opacity", mmdMaterial.DiffuseColor.a);
			material.SetColor("_AmbColor", mmdMaterial.AmbientColor);
			material.SetColor("_SpecularColor", mmdMaterial.SpecularColor);
			material.SetFloat("_Shininess", mmdMaterial.Shiness);
			material.SetFloat("_OutlineWidth", mmdMaterial.EdgeSize);
			material.SetColor("_OutlineColor", mmdMaterial.EdgeColor);
			var mainTextureStatus = ResolveMainTextureStatus(mmdMaterial, mainTexture);
			if (mainTexture == null &&
			    MainTextureStatusMissingSpec.Equals(mainTextureStatus) &&
			    ShouldUseWhiteFallbackMainTexture(mmdMaterial, transparentReason))
			{
				mainTexture = Texture2D.whiteTexture;
				mainTextureStatus = MainTextureStatusLoadedFallbackWhite;
				if (EnableTextureTraceLogs)
				{
					var fallbackReason = ResolveWhiteFallbackMainTextureReason(mmdMaterial);
					Debug.LogFormat(
						"MMD main texture fallback applied: material={0}, fallback=white, reason={1}",
						mmdMaterial.Name,
						fallbackReason);
				}
			}
			material.SetOverrideTag(MainTextureStatusTag, mainTextureStatus);
			material.SetOverrideTag(TransparentReasonTag, NormalizeTransparentReasonTag(transparentReason));
			material.SetOverrideTag(ToonTextureStatusTag, MainTextureStatusMissingSpec);
			material.SetOverrideTag(SphereAddTextureStatusTag, TextureStatusNotUsed);
			material.SetOverrideTag(SphereMulTextureStatusTag, TextureStatusNotUsed);
			if (mainTexture != null)
			{
				material.mainTexture = mainTexture;
				material.mainTextureScale = new Vector2(1, 1);
			}
			else if (MainTextureStatusMissingResolve.Equals(mainTextureStatus))
			{
				Debug.LogWarningFormat(
					"MMD main texture missing: material={0}, requested={1}, reason={2}",
					mmdMaterial.Name,
					mmdMaterial.Texture.TexturePath,
					MainTextureStatusMissingResolve);
			}
			else if (EnableTextureTraceLogs)
			{
				Debug.LogFormat(
					"MMD main texture missing: material={0}, requested=(none), reason={1}",
					mmdMaterial.Name,
					MainTextureStatusMissingSpec);
			}


			if (mmdMaterial.SubTextureType != MmdMaterial.SubTextureTypeEnum.MatSubTexOff)
			{
				var additionalTexture =
					mmdMaterial.SubTexture == null ? null : _textureLoader.LoadTexture(mmdMaterial.SubTexture);
				var requested = mmdMaterial.SubTexture != null ? mmdMaterial.SubTexture.TexturePath : string.Empty;
				var subTextureStatus = ResolveTextureStatus(requested, additionalTexture);
				if (additionalTexture != null)
				{
					additionalTexture.wrapMode = TextureWrapMode.Clamp;
					switch (mmdMaterial.SubTextureType)
					{
						case MmdMaterial.SubTextureTypeEnum.MatSubTexSpa:
							material.SetTexture("_SphereAddTex", additionalTexture);
							material.SetTextureScale("_SphereAddTex", new Vector2(1, 1));
							material.SetOverrideTag(SphereAddTextureStatusTag, subTextureStatus);
							material.SetOverrideTag(SphereMulTextureStatusTag, TextureStatusNotUsed);
							break;
						case MmdMaterial.SubTextureTypeEnum.MatSubTexSph:
							material.SetTexture("_SphereMulTex", additionalTexture);
							material.SetTextureScale("_SphereMulTex", new Vector2(1, 1));
							material.SetOverrideTag(SphereAddTextureStatusTag, TextureStatusNotUsed);
							material.SetOverrideTag(SphereMulTextureStatusTag, subTextureStatus);
							break;
					}
				}
				else
				{
					switch (mmdMaterial.SubTextureType)
					{
						case MmdMaterial.SubTextureTypeEnum.MatSubTexSpa:
							material.SetOverrideTag(SphereAddTextureStatusTag, subTextureStatus);
							material.SetOverrideTag(SphereMulTextureStatusTag, TextureStatusNotUsed);
							break;
						case MmdMaterial.SubTextureTypeEnum.MatSubTexSph:
							material.SetOverrideTag(SphereAddTextureStatusTag, TextureStatusNotUsed);
							material.SetOverrideTag(SphereMulTextureStatusTag, subTextureStatus);
							break;
					}

					if (MainTextureStatusMissingResolve.Equals(subTextureStatus))
					{
						Debug.LogWarningFormat(
							"MMD sub texture missing: material={0}, requested={1}, reason=missing_resolve",
							mmdMaterial.Name,
							requested);
					}
					else if (EnableTextureTraceLogs)
					{
						Debug.LogFormat(
							"MMD sub texture missing: material={0}, requested=(none), reason=missing_spec",
							mmdMaterial.Name);
					}
				}
			}

			RefreshShaderKeywords(mmdMaterial, config, material);

			var toonTexture = _textureLoader.LoadTexture(mmdMaterial.Toon);
			var toonRequestedPath = mmdMaterial.Toon != null ? mmdMaterial.Toon.TexturePath : string.Empty;
			var toonTextureStatus = ResolveTextureStatus(toonRequestedPath, toonTexture);
			if (toonTexture == null && ShouldUseWhiteFallbackToonTexture(toonTextureStatus))
			{
				toonTexture = Texture2D.whiteTexture;
				toonTextureStatus = MainTextureStatusLoadedFallbackWhite;
			}
			if (material.HasProperty("_MascotEdgeContributionCap"))
			{
				var edgeContributionCap = MainTextureStatusLoadedFallbackWhite.Equals(toonTextureStatus) ? 0f : 1f;
				material.SetFloat("_MascotEdgeContributionCap", edgeContributionCap);
			}
			material.SetOverrideTag(ToonTextureStatusTag, toonTextureStatus);
			if (toonTexture != null)
			{
				toonTexture.wrapMode = TextureWrapMode.Clamp;
				material.SetTexture("_ToonTex", toonTexture);
				material.SetTextureScale("_ToonTex", new Vector2(1, 1));
			}
			else
			{
				if (MainTextureStatusMissingResolve.Equals(toonTextureStatus))
				{
					Debug.LogWarningFormat(
						"MMD toon texture missing: material={0}, requested={1}, reason=missing_resolve",
						mmdMaterial.Name,
						toonRequestedPath);
				}
				else if (EnableTextureTraceLogs)
				{
					Debug.LogFormat(
						"MMD toon texture missing: material={0}, requested=(none), reason=missing_spec",
						mmdMaterial.Name);
				}
			}
		}

		private string ResolveTransparentReason(MmdMaterial mmdMaterial, Texture mainTexture, out bool isTransparent)
		{
			var byDiffuseAlpha = mmdMaterial.DiffuseColor.a < 0.9999f;
			var byEdgeAlpha = mmdMaterial.EdgeColor.a < 0.9999f;
			var byTextureAlpha = IsTextureTransparent(mainTexture);
			// Edge alpha controls outline contribution, but edge-only materials should not
			// be forced into transparent surface rendering.
			var bySurfaceTransparency = byDiffuseAlpha || byTextureAlpha;
			isTransparent = bySurfaceTransparency;
			if (!isTransparent)
			{
				return TransparentReasonOpaque;
			}
			return BuildTransparentReasonTag(byDiffuseAlpha, byEdgeAlpha, byTextureAlpha);
		}

		private static string NormalizeTransparentReasonTag(string transparentReason)
		{
			return string.IsNullOrWhiteSpace(transparentReason) ? TransparentReasonOpaque : transparentReason;
		}

		private static string BuildTransparentReasonTag(bool byDiffuseAlpha, bool byEdgeAlpha, bool byTextureAlpha)
		{
			if (!byDiffuseAlpha && !byEdgeAlpha && !byTextureAlpha)
			{
				return TransparentReasonOpaque;
			}

			var reasons = new List<string>(3);
			if (byDiffuseAlpha)
			{
				reasons.Add(TransparentReasonDiffuseAlpha);
			}

			if (byEdgeAlpha)
			{
				reasons.Add(TransparentReasonEdgeAlpha);
			}

			if (byTextureAlpha)
			{
				reasons.Add(TransparentReasonTextureAlpha);
			}

			return string.Join("+", reasons.ToArray());
		}

		private static string ResolveMainTextureStatus(MmdMaterial mmdMaterial, Texture mainTexture)
		{
			if (mainTexture != null)
			{
				return MainTextureStatusLoaded;
			}

			if (mmdMaterial.Texture == null || string.IsNullOrEmpty(mmdMaterial.Texture.TexturePath))
			{
				return MainTextureStatusMissingSpec;
			}

			return MainTextureStatusMissingResolve;
		}

		private static string ResolveTextureStatus(string requestedPath, Texture texture)
		{
			if (texture != null)
			{
				return MainTextureStatusLoaded;
			}

			if (string.IsNullOrEmpty(requestedPath))
			{
				return MainTextureStatusMissingSpec;
			}

			return MainTextureStatusMissingResolve;
		}

		private static bool ShouldUseWhiteFallbackToonTexture(string toonTextureStatus)
		{
			return MainTextureStatusMissingSpec.Equals(toonTextureStatus);
		}

		private static bool ShouldUseWhiteFallbackMainTexture(MmdMaterial mmdMaterial, string _transparentReason)
		{
			if (mmdMaterial == null)
			{
				return false;
			}
			return ShouldUseShadowWhiteFallback(mmdMaterial);
		}

		private static bool ShouldUseShadowWhiteFallback(MmdMaterial mmdMaterial)
		{
			if (mmdMaterial == null)
			{
				return false;
			}

			var materialName = mmdMaterial.Name ?? string.Empty;
			var hasShadowKeyword = materialName.IndexOf("shadow", StringComparison.OrdinalIgnoreCase) >= 0;
			if (!hasShadowKeyword)
			{
				return false;
			}

			// Untextured low-alpha shadow meshes are optional overlays in some PMX assets.
			// Using white texture keeps shading stable while preserving diffuse alpha.
			return mmdMaterial.DiffuseColor.a <= 0.25f;
		}

		private static string ResolveWhiteFallbackMainTextureReason(MmdMaterial mmdMaterial)
		{
			if (ShouldUseShadowWhiteFallback(mmdMaterial))
			{
				return "optional_shadow_spec_missing";
			}

			return "unknown";
		}

		private void RefreshShaderKeywords(MmdMaterial mmdMaterial, MmdUnityConfig config, UnityEngine.Material material)
		{
			RefreshDrawSelfShadowKeyword(MmdUnityConfig.DealSwitch(config.EnableDrawSelfShadow, mmdMaterial.DrawSelfShadow),
				material);
		}

		private void RefreshDrawSelfShadowKeyword(bool drawSelfshadow, UnityEngine.Material material)
		{
			if (drawSelfshadow)
			{
				material.EnableKeyword("SELFSHADOW_ON");
				material.DisableKeyword("SELFSHADOW_OFF");
			}
			else
			{
				material.DisableKeyword("SELFSHADOW_ON");
				material.EnableKeyword("SELFSHADOW_OFF");
			}
		}
			
		public void Dispose ()
		{
			_textureTransparencyCache.Clear();
			if (_textureLoader != null) {
				_textureLoader.Dispose ();
			}
		}
			
		private static Shader GetShader(MmdMaterial mmdMaterial, MmdUnityConfig config, bool isTransparent)
		{
			//"MMD/Transparent/PMDMaterial-with-Outline-CullBack-NoCastShadow"
			var shaderName = BuildShaderName(mmdMaterial, config, isTransparent);
			var ret = Shader.Find (shaderName);
			if (ret == null) {
				Debug.LogWarning("Can't find shader "+ shaderName);
			}
			return ret;
		}

		private static string BuildShaderName(MmdMaterial mmdMaterial, MmdUnityConfig config, bool isTransparent)
		{
			var shaderNameBuilder = new StringBuilder();
			shaderNameBuilder.Append("MMD/");
			if (isTransparent)
			{
				shaderNameBuilder.Append("Transparent/");
			}
			shaderNameBuilder.Append("PMDMaterial");
			if (MmdUnityConfig.DealSwitch(config.EnableEdge, mmdMaterial.DrawEdge))
			{
				shaderNameBuilder.Append("-with-Outline");
			}
			if (!mmdMaterial.DrawDoubleFace)
			{
				shaderNameBuilder.Append("-CullBack");
			}
			if (!MmdUnityConfig.DealSwitch(config.EnableCastShadow, mmdMaterial.CastSelfShadow))
			{
				shaderNameBuilder.Append("-NoCastShadow");
			}
			var shaderName = shaderNameBuilder.ToString();
			return shaderName;
		}

		private bool IsTextureTransparent(Texture texture) {
			try {
				var tex2D = texture as Texture2D;
				if (tex2D == null) {
					return false;
				}
				var cacheKey = tex2D.GetInstanceID();
				bool cached;
				if (_textureTransparencyCache.TryGetValue(cacheKey, out cached))
				{
					return cached;
				}
				var pixels = tex2D.GetPixels ();
				var isTransparent = IsTextureTransparentByPixels(pixels);
				_textureTransparencyCache[cacheKey] = isTransparent;
				return isTransparent;
			} catch {
				// Keep old behavior: on read failure, treat as opaque.
			}
			return false;
		}

		private static bool IsTextureTransparentByPixels(Color[] pixels)
		{
			if (pixels == null || pixels.Length == 0)
			{
				return false;
			}

			var strongTransparentPixelCount = 0;
			var semiTransparentPixelCount = 0;
			for (var i = 0; i < pixels.Length; i++)
			{
				var alpha = pixels[i].a;
				if (alpha < StrongTransparentAlphaThreshold)
				{
					strongTransparentPixelCount++;
				}
				if (alpha < SemiTransparentAlphaThreshold)
				{
					semiTransparentPixelCount++;
				}
			}

			var requiredStrongTransparentPixels =
				CalculateRequiredTransparentPixels(pixels.Length, StrongTransparentPixelRatioThreshold);
			if (strongTransparentPixelCount >= requiredStrongTransparentPixels)
			{
				return true;
			}

			var requiredSemiTransparentPixels =
				CalculateRequiredTransparentPixels(pixels.Length, SemiTransparentPixelRatioThreshold);
			return semiTransparentPixelCount >= requiredSemiTransparentPixels;
		}

		private static int CalculateRequiredTransparentPixels(int totalPixels, float ratioThreshold)
		{
			if (totalPixels <= 0 || ratioThreshold <= 0f)
			{
				return 0;
			}

			if (ratioThreshold >= 1f)
			{
				return totalPixels;
			}

			// Keep "at threshold" behavior stable by avoiding float boundary drift.
			var requiredPixels = Mathf.CeilToInt(totalPixels * ratioThreshold - RatioThresholdEpsilon);
			return Mathf.Clamp(requiredPixels, 1, totalPixels);
		}
	}
		
}
